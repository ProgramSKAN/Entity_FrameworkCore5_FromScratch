# Entity_FrameworkCore5_FromScratch

1. create ASP.net core web app > Wiblib
2. create data clas libraries


packages:

Microsoft.EntityFrameworkCore > install in webapp,dataaccess project
Microsoft.EntityFrameworkCore.SQLServer > install in webapp,dataaccess

## DBContext
* Instance of DBContext represents a session with th DB which can be used to query and save instances of your entities to a database.
* its allows to perform
    * Manage database connection
    * configure model & relationship
    * Querying database
    * Saving data to database
    * configure change tracking
    * Caching
    * Transation management


* Model class + Mappings => Database 
* Database must be in synk with models and mappings

## Migrations in EFCore
1. Change/ Create Model :You should first create new model or change existing model
2. Add Migration: Add a new migration once you make your changes to see what will be pushed to database
3. Apply Migration: Once a migration is added use the updated-database to push migration

* install package > Microsoft.EntityFrameworkCore.Tools > install in webapp,dataaccess

Goto > Tools > nuget package manager > package manager console

run inside dataAccess project because DBContext classes exist there. Also startup project as web app.(if you keep model project as startup it throws error as it is not using DBContext)

    >   add-migration AddCategoryTableToDb

* above command creates a migration file (xxxx_AddCategoryTableToDb) and snapshot file (ApplicationDbContextModelSnapShot)
* snapshot class file keeps a backup of what exactly as been pushed to database so far. it is a tracker of what migration as been applied and what is the current state of DB.so it can push the difference during update-databse command

 >  update-databse

 * above command pushes the migration to DB

 * NOTE: always create small changes migrations so it can be identitied with name. also easy to rollback

 >   add-migration AddGenreTableToDb

 ## Migration Scenarios
 1. Add a new class/table in the db
 2. Add new property/column to table
 3. Modify existing property/column in a table
 4. Delete existing property/column in a table
 5. Delete a class/table in the database

>  add-migration AddDisplayOrderToGenreTable
* new migration to add new column

>  add-migration ChangeNameToGenereNameInGenreTable

 * above command could result in loss of data as it deletes and add new column
 * to avoid this run SQL staatement (copy) before running dropColumn inside "xxxx_ChangeNameToGenreNameInGenreTable" migration file

> add-migration RemoveDisplayOrderColumnFromGenreTable
* causes data loss

* NOTE: whenever you deal with migrations, if you donno, don't delete migration class in migrations folder. DB will become unstable state.
else In beginning you can delete all migrations folder and run new migrations in new database. don't keep changes names and props in migrations folder, will be inconsistant db.
* migrations are source countrol friendly

 > update-database AddGenreTableToDb
 * above command revert the state of the DB to AddGenreTableToDb migration
* now you can work with that state

> update-database
* above command make the DB back to current state by running all migrations

* check the migrations history in migrations table

#### to remove migrations
1. run 'update-database lastMigrationNameYouWantDbTobe' then delete following migrations. (not recommanded)
2. change the models and add new migration (prefer) 

## How EF Core does mappings to DB
1. Conventions : there are default assumptions
    * eg: property name in the class will be column name in the table
2. Data Annotations: you can apply then in model/class files
    * [key] public int Genre_Id{get;ste;}
3. Fluent API: Apply the in DBContext of the project
    * modelBuilder.Entity{Genre}().HasKey(b=>b.Genre_Id)

> add-migration ChangeTableAndColumnNameOfGenreTableUsingAnnotaions

## Mapping
1. Book-Category > 1:1 > each book have one category
* book has foreign key of Category_Id

2. Book-Author > many:many > author can have many book ans single book have many authors
3. Book-Publisher > 1:many >single book has 1 publisher. but 1 publisher publishes many books
4. Book-BookDetail > 1:1 relation

> add-migration AddBooksTableToDb

> add-migration AddMaxLengthToISBMinBooksTable

> add-migration AddAuthorANdPublisherTableToDb


## Database Generated Attribute
* this can used with data annototions (like below) or fluent API 

// [DatabaseGenerated(DatabaseGeneratedOption.Identity)]//default
//[DatabaseGenerated(DatabaseGeneratedOption.None)] 
//[DatabaseGenerated(DatabaseGeneratedOption.Computed)]

public int Author_Id { get; set; }

1.Identity : it specifies that value of the property will only be generated by the database when the value is first added to DB. EFcore will not implement a value generation strategy. DB provides differ in the way that values are automatically generated. EG: Identity, GUID

2.None: it prevents the values from being generated by the database automatically in cases where they would otherwise be created

3.Computed: the property value will be generated by DB when value is first saved and subsequently regenerated every time the value is updated

## Fluent API
* it is advance way of specifying the model configurations that covers everything that data annotations can do inaddition to some advance configuration which is not possible with data annotations. eg: composite key
* Data annotaions and fluent API can be used together. but code first gives precedence to fluent API than data annotations and default conventions
* Fluent API is just another way to create domain classes
* it is used inside onModelCreate() override inside DBContext

* Demo: repeat same above models using fluent api.

Fluent_Book.cs, Fluent_Author.cs, Fluent_BookAuthor.cs, Fluent_BookDetail.cs,  Fluent_Publisher.cs


## Bulk Insert or delete
* done using AddRange or RemoveRange
* adding 2 > runs 2 insert statements
* add 5 > runs all in single insert. ie, bulk insert. the default threshold in sql server provider that starts using batch commands for >=4 operations
* using Add() in a for loop OR AddRange() by passing list > both are same. bulk append only if records >=4

* Similarly Remove2 runs in 2 different delete statements, Remove5 runs in bulk


## Projections in EF Core
* it is a way for translating a full entity into a C# class with a subset of those properties
* it is used to create a query that selects from a set of entities in your model but returns results that are of a different type.

eg: select only few columns from customers table. ie, customer data is projected to anonymous type
> var customer= context.customers.Select(cust=>new{Id=cust.CustomerId,FullName=cust.FirstName+cust.LastName}).ToList()

## Eager Loading
all the connected entities are loading by one query using joins

using>      .Include()

## Deferred Execution in EF Core
* queries in EF core are not execute when they are created
* they are executed under the following scenarios

1. when they are iterated over
```
var bookCollection=_db.books;
double totalPrice=0;
foreach(var book in bookCollection){  >query executes here
    tottalPrice += book.Price;
}
```
2. Call ToDictionary, ToList, ToArray on the reault
```
var bookCollection=_db.books.ToList();    >query executes here
double totalPrice=0;
foreach(var book in bookCollection){
    tottalPrice += book.Price;
}
```
3. Call any method that return single object (First, SIngle, Count, Max,...etc)
```
var bookCollection=_db.books;
var bookCount1=bookCollection.Count(); >query executes here
var bookCount2=_db.books.Count(); >query executes here
}
```
## IQueryable vs IEnumerable
* IQueryable interface inherits from IEnumerable
* Anything you do with IEnumerable can be done with IQueryable
* IEnumerable filters data on client side. IQueryable filters data on DB side

1. this queries all records in a books table without where clause. after that filter happens in code
```
IEnumerable<Books> BookList = _db.Books;
var FilteredBook= BookList.Where(b=>b.Price>500).ToList();
```

2. this queries only records >500 in a books table with where clause
```
IQueryable<Books> BookList = _db.Books;
var FilteredBook= BookList.Where(b=>b.Price>500).ToList();
```

## Attach vs Update
* Attach puts all entities into the 'UNCHANGED' state. however entities will be put in the 'ADDED' state if they have stored generated keys like identity column and no key value has been set.
* Attach is used to tracking a mix of new and existing things where existing things had not changed.
* the new entities will be inserted while the existing enities will not be saved other than to update any necessary foreign key values.

* Update works same as attached except that entities are put in 'MODIFIED' state instead of 'UNCHANGED' state.
* So if everything is in modified state, when you see the changes it will update everything

* therefore,Attach puts all th enties in the graph in the unchanged state however if something from that unchanged state is modified, Attach will change its state to modified.